Skia 中一条渲染指令的执行时间大约小于0.1ms。

# 光栅化

光栅化指的是，将几何数据（绘图指令产生的数据）经过一些列变换，最终转换成像素数据（RGB）的过程。

[参考1](https://zhuanlan.zhihu.com/p/78758247)

[参考2](https://zhuanlan.zhihu.com/p/81974121)

# 浏览器中的光栅化

Chromium 采用的是异步分块光栅化。即将图层切割为多个缓冲区，其光栅化和合成是异步的，如果某个区块中没有完成光栅化，就会显示为空白。

异步分块光栅化需要为每个合成器分配一个分块的缓存资源池，用于分配和回收像素缓冲区。Android WebView 默认分配的大小为 WebView 大小的 10 倍 ～ 20 倍。


# Flutter 中的光栅化

## 同步光栅化的优势：

1. 光栅化同时能够节省为合成器分配的内存

2. 同步光栅化由于少了派发光栅化任务，等待光栅化完成再合成等步骤，而是直接发起光栅化合成，所以同等条件下首屏渲染完成耗时会比异步光栅化快1-2帧，即2、30毫秒

3. 动态变化的内容会使光栅化缓存失效，对于异步光栅化需要重新光栅化到缓存区，再合成，而同步光栅化本身就是同步的过程，因此效率会更高。

## 同步光栅化不可避免的耗时点：

1. 位图解码、绘制路径计算、剪裁等是在CPU中运算完成的，需要把结果上传到GPU中，这部分会带来几十到几百毫秒的耗时。

2. 位图解码会比较耗时，如果同步进行，会阻塞渲染

在 Flutter 中，存在两种类型的同步光栅化：

## 1. 直接光栅化

将图层 DisplayList 中的绘图指令，执行光栅化直接在目标 Surface 缓冲区上写生成的像素数据。

（注：DisplayList 是就是绘图指令列表。通常由 UI 框架的 Paint 操作生成。）

直接光栅化通常没有 Composite 图层合成的步骤的。





## 2. 间接光栅化

为图层分配独立的缓冲区，将光栅化数据先写入自己的缓冲区，然后再将缓冲区的像素数据合成一起写入目标 Surface 中。

### 间接光栅化的副作用：

- 间接光栅化由于需要开辟新的内存区域，实际上可能会增加当前帧的开销，但能够节省后续帧的开销

- 如果图层内容频繁变化，独立的图层也需要频繁刷新，反而会增加每帧的绘制开销

以上两种光栅化都是同步光栅化（即时光栅化），光栅化和合成始终是串行执行的。

直接光栅化在动态内容的渲染性能场景下，GPU 内存占用和性能略由于异步光栅化，但惯性滚动略逊于异步光栅化。

### RepaintBoundary

使用 RepaintBoundary 能够提示渲染引擎该区域可能需要采用间接光栅化。

但实际是否采用间接光栅化，会有一些条件限制：

1. 每一帧最多允许 3 个图层使用间接光栅化

2. IsPictureWorthRasterizing 会检查图层的绘制指令复杂度，必须足够复杂才会使用间接光栅化，否则还是采用直接光栅化

3. access_threshold 会限制图层内容在连续 3 帧没有变化，才会采取间接光栅化，否则采用直接光栅化

### 间接光栅化缓冲区失效

如果图层发生了非平移变换（如旋转、缩放），缓冲区的像素数据就会失效，需要重新进行光栅化。如果只是平移，则可以一直复用缓存。

### OpacityLayer 图层

OpacityLayer 和普通的 PictureLayer 不同，它不受任何条件限制，会直接采用间接光栅化。后续 alpha 值的变化，只需在输出缓冲时，修改 alpha 值即可。

### 间接光栅化缓冲区的回收

Flutter 中，间接光栅化的缓冲区大小上限默认为 FlutterView 面积的 12 倍。

GPU 内分配的缓冲区，如果在 15s 内都没有被重用，才会真正的被释放。而 Flutter 生成的缓存图层，如果在一帧内没有被绘制，就会立即被释放。



